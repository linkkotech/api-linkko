// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: activities.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createActivity = `-- name: CreateActivity :one
INSERT INTO "Activity" (
    id, "workspaceId", "companyId", "contactId", "dealId",
    "activityType", "activityId", "userId", metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, "workspaceId", "companyId", "contactId", "dealId", "activityType", "activityId", "userId", metadata, "createdAt"
`

type CreateActivityParams struct {
	ID           string       `json:"id"`
	WorkspaceId  string       `json:"workspaceId"`
	CompanyId    *string      `json:"companyId"`
	ContactId    *string      `json:"contactId"`
	DealId       *string      `json:"dealId"`
	ActivityType ActivityType `json:"activityType"`
	ActivityId   *string      `json:"activityId"`
	UserId       string       `json:"userId"`
	Metadata     []byte       `json:"metadata"`
}

func (q *Queries) CreateActivity(ctx context.Context, arg CreateActivityParams) (Activity, error) {
	row := q.db.QueryRow(ctx, createActivity,
		arg.ID,
		arg.WorkspaceId,
		arg.CompanyId,
		arg.ContactId,
		arg.DealId,
		arg.ActivityType,
		arg.ActivityId,
		arg.UserId,
		arg.Metadata,
	)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.WorkspaceId,
		&i.CompanyId,
		&i.ContactId,
		&i.DealId,
		&i.ActivityType,
		&i.ActivityId,
		&i.UserId,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createCall = `-- name: CreateCall :one
INSERT INTO "Call" (
    id, "workspaceId", "contactId", "companyId",
    direction, duration, "recordingUrl", summary, "userId", "calledAt"
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, "workspaceId", "contactId", "companyId", direction, duration, "recordingUrl", summary, "userId", "calledAt", "createdAt"
`

type CreateCallParams struct {
	ID           string           `json:"id"`
	WorkspaceId  string           `json:"workspaceId"`
	ContactId    string           `json:"contactId"`
	CompanyId    *string          `json:"companyId"`
	Direction    MessageDirection `json:"direction"`
	Duration     *int32           `json:"duration"`
	RecordingUrl *string          `json:"recordingUrl"`
	Summary      *string          `json:"summary"`
	UserId       string           `json:"userId"`
	CalledAt     pgtype.Timestamp `json:"calledAt"`
}

func (q *Queries) CreateCall(ctx context.Context, arg CreateCallParams) (Call, error) {
	row := q.db.QueryRow(ctx, createCall,
		arg.ID,
		arg.WorkspaceId,
		arg.ContactId,
		arg.CompanyId,
		arg.Direction,
		arg.Duration,
		arg.RecordingUrl,
		arg.Summary,
		arg.UserId,
		arg.CalledAt,
	)
	var i Call
	err := row.Scan(
		&i.ID,
		&i.WorkspaceId,
		&i.ContactId,
		&i.CompanyId,
		&i.Direction,
		&i.Duration,
		&i.RecordingUrl,
		&i.Summary,
		&i.UserId,
		&i.CalledAt,
		&i.CreatedAt,
	)
	return i, err
}

const createMeeting = `-- name: CreateMeeting :one
INSERT INTO "Meeting" (
    id, "workspaceId", title, description, "meetingType",
    "startTime", "endTime", location, "meetingUrl", "externalId", "userId"
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, "workspaceId", title, description, "meetingType", "startTime", "endTime", location, "meetingUrl", "externalId", "userId", "deletedAt", "createdAt", "updatedAt"
`

type CreateMeetingParams struct {
	ID          string           `json:"id"`
	WorkspaceId string           `json:"workspaceId"`
	Title       string           `json:"title"`
	Description *string          `json:"description"`
	MeetingType MeetingType      `json:"meetingType"`
	StartTime   pgtype.Timestamp `json:"startTime"`
	EndTime     pgtype.Timestamp `json:"endTime"`
	Location    *string          `json:"location"`
	MeetingUrl  *string          `json:"meetingUrl"`
	ExternalId  *string          `json:"externalId"`
	UserId      string           `json:"userId"`
}

func (q *Queries) CreateMeeting(ctx context.Context, arg CreateMeetingParams) (Meeting, error) {
	row := q.db.QueryRow(ctx, createMeeting,
		arg.ID,
		arg.WorkspaceId,
		arg.Title,
		arg.Description,
		arg.MeetingType,
		arg.StartTime,
		arg.EndTime,
		arg.Location,
		arg.MeetingUrl,
		arg.ExternalId,
		arg.UserId,
	)
	var i Meeting
	err := row.Scan(
		&i.ID,
		&i.WorkspaceId,
		&i.Title,
		&i.Description,
		&i.MeetingType,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.MeetingUrl,
		&i.ExternalId,
		&i.UserId,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO "Message" (
    id, "workspaceId", "contactId", "companyId",
    direction, platform, content, status, "sentAt", "userId"
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, "workspaceId", "contactId", "companyId", direction, platform, content, status, "sentAt", "userId", "createdAt"
`

type CreateMessageParams struct {
	ID          string           `json:"id"`
	WorkspaceId string           `json:"workspaceId"`
	ContactId   string           `json:"contactId"`
	CompanyId   *string          `json:"companyId"`
	Direction   MessageDirection `json:"direction"`
	Platform    string           `json:"platform"`
	Content     string           `json:"content"`
	Status      MessageStatus    `json:"status"`
	SentAt      pgtype.Timestamp `json:"sentAt"`
	UserId      string           `json:"userId"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ID,
		arg.WorkspaceId,
		arg.ContactId,
		arg.CompanyId,
		arg.Direction,
		arg.Platform,
		arg.Content,
		arg.Status,
		arg.SentAt,
		arg.UserId,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.WorkspaceId,
		&i.ContactId,
		&i.CompanyId,
		&i.Direction,
		&i.Platform,
		&i.Content,
		&i.Status,
		&i.SentAt,
		&i.UserId,
		&i.CreatedAt,
	)
	return i, err
}

const createNote = `-- name: CreateNote :one
INSERT INTO "Note" (
    id, "workspaceId", "companyId", "contactId", "dealId",
    content, "isPinned", "userId"
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, "workspaceId", "companyId", "contactId", "dealId", content, "isPinned", "userId", "deletedAt", "createdAt", "updatedAt"
`

type CreateNoteParams struct {
	ID          string  `json:"id"`
	WorkspaceId string  `json:"workspaceId"`
	CompanyId   *string `json:"companyId"`
	ContactId   *string `json:"contactId"`
	DealId      *string `json:"dealId"`
	Content     string  `json:"content"`
	IsPinned    bool    `json:"isPinned"`
	UserId      string  `json:"userId"`
}

func (q *Queries) CreateNote(ctx context.Context, arg CreateNoteParams) (Note, error) {
	row := q.db.QueryRow(ctx, createNote,
		arg.ID,
		arg.WorkspaceId,
		arg.CompanyId,
		arg.ContactId,
		arg.DealId,
		arg.Content,
		arg.IsPinned,
		arg.UserId,
	)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.WorkspaceId,
		&i.CompanyId,
		&i.ContactId,
		&i.DealId,
		&i.Content,
		&i.IsPinned,
		&i.UserId,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActivities = `-- name: ListActivities :many
SELECT id, "workspaceId", "companyId", "contactId", "dealId", "activityType", "activityId", "userId", metadata, "createdAt" FROM "Activity"
WHERE "workspaceId" = $1
    AND ($2::TEXT IS NULL OR "contactId" = $2)
    AND ($3::TEXT IS NULL OR "companyId" = $3)
    AND ($4::TEXT IS NULL OR "dealId" = $4)
ORDER BY "createdAt" DESC
`

type ListActivitiesParams struct {
	WorkspaceId string  `json:"workspaceId"`
	ContactId   *string `json:"contactId"`
	CompanyId   *string `json:"companyId"`
	DealId      *string `json:"dealId"`
}

func (q *Queries) ListActivities(ctx context.Context, arg ListActivitiesParams) ([]Activity, error) {
	rows, err := q.db.Query(ctx, listActivities,
		arg.WorkspaceId,
		arg.ContactId,
		arg.CompanyId,
		arg.DealId,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceId,
			&i.CompanyId,
			&i.ContactId,
			&i.DealId,
			&i.ActivityType,
			&i.ActivityId,
			&i.UserId,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
