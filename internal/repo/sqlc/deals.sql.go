// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: deals.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDeal = `-- name: CreateDeal :one
INSERT INTO "Deal" (
    id, "workspaceId", "pipelineId", "stageId", "contactId", "companyId",
    name, value, currency, stage, probability, 
    "expectedCloseDate", "ownerId", "createdById", description
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
) RETURNING id, "workspaceId", "pipelineId", "stageId", "contactId", name, value, "createdAt", "updatedAt", "deletedAt", "deletedById", description, currency, stage, probability, "expectedCloseDate", "closedAt", "lostReason", "companyId", "ownerId", "createdById", "updatedById"
`

type CreateDealParams struct {
	ID                string           `json:"id"`
	WorkspaceId       string           `json:"workspaceId"`
	PipelineId        string           `json:"pipelineId"`
	StageId           *string          `json:"stageId"`
	ContactId         *string          `json:"contactId"`
	CompanyId         *string          `json:"companyId"`
	Name              string           `json:"name"`
	Value             *float64         `json:"value"`
	Currency          string           `json:"currency"`
	Stage             DealStage        `json:"stage"`
	Probability       *int32           `json:"probability"`
	ExpectedCloseDate pgtype.Timestamp `json:"expectedCloseDate"`
	OwnerId           *string          `json:"ownerId"`
	CreatedById       string           `json:"createdById"`
	Description       *string          `json:"description"`
}

func (q *Queries) CreateDeal(ctx context.Context, arg CreateDealParams) (Deal, error) {
	row := q.db.QueryRow(ctx, createDeal,
		arg.ID,
		arg.WorkspaceId,
		arg.PipelineId,
		arg.StageId,
		arg.ContactId,
		arg.CompanyId,
		arg.Name,
		arg.Value,
		arg.Currency,
		arg.Stage,
		arg.Probability,
		arg.ExpectedCloseDate,
		arg.OwnerId,
		arg.CreatedById,
		arg.Description,
	)
	var i Deal
	err := row.Scan(
		&i.ID,
		&i.WorkspaceId,
		&i.PipelineId,
		&i.StageId,
		&i.ContactId,
		&i.Name,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.DeletedById,
		&i.Description,
		&i.Currency,
		&i.Stage,
		&i.Probability,
		&i.ExpectedCloseDate,
		&i.ClosedAt,
		&i.LostReason,
		&i.CompanyId,
		&i.OwnerId,
		&i.CreatedById,
		&i.UpdatedById,
	)
	return i, err
}

const createDealHistory = `-- name: CreateDealHistory :one
INSERT INTO "DealStageHistory" (
    id, "workspaceId", "dealId", "fromStage", "toStage", reason, "userId"
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, "workspaceId", "dealId", "fromStage", "toStage", reason, "userId", "createdAt"
`

type CreateDealHistoryParams struct {
	ID          string    `json:"id"`
	WorkspaceId string    `json:"workspaceId"`
	DealId      string    `json:"dealId"`
	FromStage   DealStage `json:"fromStage"`
	ToStage     DealStage `json:"toStage"`
	Reason      *string   `json:"reason"`
	UserId      string    `json:"userId"`
}

func (q *Queries) CreateDealHistory(ctx context.Context, arg CreateDealHistoryParams) (DealStageHistory, error) {
	row := q.db.QueryRow(ctx, createDealHistory,
		arg.ID,
		arg.WorkspaceId,
		arg.DealId,
		arg.FromStage,
		arg.ToStage,
		arg.Reason,
		arg.UserId,
	)
	var i DealStageHistory
	err := row.Scan(
		&i.ID,
		&i.WorkspaceId,
		&i.DealId,
		&i.FromStage,
		&i.ToStage,
		&i.Reason,
		&i.UserId,
		&i.CreatedAt,
	)
	return i, err
}

const deleteDeal = `-- name: DeleteDeal :exec
UPDATE "Deal"
SET 
    "deletedAt" = CURRENT_TIMESTAMP,
    "deletedById" = $3
WHERE id = $1 AND "workspaceId" = $2
`

type DeleteDealParams struct {
	ID          string  `json:"id"`
	WorkspaceId string  `json:"workspaceId"`
	DeletedById *string `json:"deletedById"`
}

func (q *Queries) DeleteDeal(ctx context.Context, arg DeleteDealParams) error {
	_, err := q.db.Exec(ctx, deleteDeal, arg.ID, arg.WorkspaceId, arg.DeletedById)
	return err
}

const getDeal = `-- name: GetDeal :one
SELECT 
    d.id, d."workspaceId", d."pipelineId", d."stageId", d."contactId", d.name, d.value, d."createdAt", d."updatedAt", d."deletedAt", d."deletedById", d.description, d.currency, d.stage, d.probability, d."expectedCloseDate", d."closedAt", d."lostReason", d."companyId", d."ownerId", d."createdById", d."updatedById",
    c."fullName" as contactName,
    co.name as companyName
FROM "Deal" d
LEFT JOIN "Contact" c ON d."contactId" = c.id
LEFT JOIN "Company" co ON d."companyId" = co.id
WHERE d.id = $1 AND d."workspaceId" = $2 AND d."deletedAt" IS NULL
`

type GetDealParams struct {
	ID          string `json:"id"`
	WorkspaceId string `json:"workspaceId"`
}

type GetDealRow struct {
	ID                string           `json:"id"`
	WorkspaceId       string           `json:"workspaceId"`
	PipelineId        string           `json:"pipelineId"`
	StageId           *string          `json:"stageId"`
	ContactId         *string          `json:"contactId"`
	Name              string           `json:"name"`
	Value             *float64         `json:"value"`
	CreatedAt         pgtype.Timestamp `json:"createdAt"`
	UpdatedAt         pgtype.Timestamp `json:"updatedAt"`
	DeletedAt         pgtype.Timestamp `json:"deletedAt"`
	DeletedById       *string          `json:"deletedById"`
	Description       *string          `json:"description"`
	Currency          string           `json:"currency"`
	Stage             DealStage        `json:"stage"`
	Probability       *int32           `json:"probability"`
	ExpectedCloseDate pgtype.Timestamp `json:"expectedCloseDate"`
	ClosedAt          pgtype.Timestamp `json:"closedAt"`
	LostReason        *string          `json:"lostReason"`
	CompanyId         *string          `json:"companyId"`
	OwnerId           *string          `json:"ownerId"`
	CreatedById       string           `json:"createdById"`
	UpdatedById       *string          `json:"updatedById"`
	Contactname       *string          `json:"contactname"`
	Companyname       *string          `json:"companyname"`
}

func (q *Queries) GetDeal(ctx context.Context, arg GetDealParams) (GetDealRow, error) {
	row := q.db.QueryRow(ctx, getDeal, arg.ID, arg.WorkspaceId)
	var i GetDealRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceId,
		&i.PipelineId,
		&i.StageId,
		&i.ContactId,
		&i.Name,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.DeletedById,
		&i.Description,
		&i.Currency,
		&i.Stage,
		&i.Probability,
		&i.ExpectedCloseDate,
		&i.ClosedAt,
		&i.LostReason,
		&i.CompanyId,
		&i.OwnerId,
		&i.CreatedById,
		&i.UpdatedById,
		&i.Contactname,
		&i.Companyname,
	)
	return i, err
}

const listDeals = `-- name: ListDeals :many
SELECT 
    d.id, d."workspaceId", d."pipelineId", d."stageId", d."contactId", d.name, d.value, d."createdAt", d."updatedAt", d."deletedAt", d."deletedById", d.description, d.currency, d.stage, d.probability, d."expectedCloseDate", d."closedAt", d."lostReason", d."companyId", d."ownerId", d."createdById", d."updatedById",
    c."fullName" as contactName,
    co.name as companyName
FROM "Deal" d
LEFT JOIN "Contact" c ON d."contactId" = c.id
LEFT JOIN "Company" co ON d."companyId" = co.id
WHERE d."workspaceId" = $1 
    AND ($2::TEXT IS NULL OR d."pipelineId" = $2)
    AND ($3::TEXT IS NULL OR d."stageId" = $3)
    AND ($4::TEXT IS NULL OR d."ownerId" = $4)
    AND d."deletedAt" IS NULL
ORDER BY d."createdAt" DESC
`

type ListDealsParams struct {
	WorkspaceId string  `json:"workspaceId"`
	PipelineId  *string `json:"pipelineId"`
	StageId     *string `json:"stageId"`
	OwnerId     *string `json:"ownerId"`
}

type ListDealsRow struct {
	ID                string           `json:"id"`
	WorkspaceId       string           `json:"workspaceId"`
	PipelineId        string           `json:"pipelineId"`
	StageId           *string          `json:"stageId"`
	ContactId         *string          `json:"contactId"`
	Name              string           `json:"name"`
	Value             *float64         `json:"value"`
	CreatedAt         pgtype.Timestamp `json:"createdAt"`
	UpdatedAt         pgtype.Timestamp `json:"updatedAt"`
	DeletedAt         pgtype.Timestamp `json:"deletedAt"`
	DeletedById       *string          `json:"deletedById"`
	Description       *string          `json:"description"`
	Currency          string           `json:"currency"`
	Stage             DealStage        `json:"stage"`
	Probability       *int32           `json:"probability"`
	ExpectedCloseDate pgtype.Timestamp `json:"expectedCloseDate"`
	ClosedAt          pgtype.Timestamp `json:"closedAt"`
	LostReason        *string          `json:"lostReason"`
	CompanyId         *string          `json:"companyId"`
	OwnerId           *string          `json:"ownerId"`
	CreatedById       string           `json:"createdById"`
	UpdatedById       *string          `json:"updatedById"`
	Contactname       *string          `json:"contactname"`
	Companyname       *string          `json:"companyname"`
}

func (q *Queries) ListDeals(ctx context.Context, arg ListDealsParams) ([]ListDealsRow, error) {
	rows, err := q.db.Query(ctx, listDeals,
		arg.WorkspaceId,
		arg.PipelineId,
		arg.StageId,
		arg.OwnerId,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDealsRow{}
	for rows.Next() {
		var i ListDealsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceId,
			&i.PipelineId,
			&i.StageId,
			&i.ContactId,
			&i.Name,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.DeletedById,
			&i.Description,
			&i.Currency,
			&i.Stage,
			&i.Probability,
			&i.ExpectedCloseDate,
			&i.ClosedAt,
			&i.LostReason,
			&i.CompanyId,
			&i.OwnerId,
			&i.CreatedById,
			&i.UpdatedById,
			&i.Contactname,
			&i.Companyname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDeal = `-- name: UpdateDeal :one
UPDATE "Deal"
SET 
    "pipelineId" = COALESCE($3, "pipelineId"),
    "stageId" = COALESCE($4, "stageId"),
    name = COALESCE($5, name),
    value = COALESCE($6, value),
    currency = COALESCE($7, currency),
    stage = COALESCE($8, stage),
    probability = COALESCE($9, probability),
    "expectedCloseDate" = COALESCE($10, "expectedCloseDate"),
    "closedAt" = COALESCE($11, "closedAt"),
    "lostReason" = COALESCE($12, "lostReason"),
    "ownerId" = COALESCE($13, "ownerId"),
    description = COALESCE($14, description),
    "updatedAt" = CURRENT_TIMESTAMP,
    "updatedById" = $15
WHERE id = $1 AND "workspaceId" = $2 AND "deletedAt" IS NULL
RETURNING id, "workspaceId", "pipelineId", "stageId", "contactId", name, value, "createdAt", "updatedAt", "deletedAt", "deletedById", description, currency, stage, probability, "expectedCloseDate", "closedAt", "lostReason", "companyId", "ownerId", "createdById", "updatedById"
`

type UpdateDealParams struct {
	ID                string           `json:"id"`
	WorkspaceId       string           `json:"workspaceId"`
	PipelineId        *string          `json:"pipelineId"`
	StageId           *string          `json:"stageId"`
	Name              *string          `json:"name"`
	Value             *float64         `json:"value"`
	Currency          *string          `json:"currency"`
	Stage             NullDealStage    `json:"stage"`
	Probability       *int32           `json:"probability"`
	ExpectedCloseDate pgtype.Timestamp `json:"expectedCloseDate"`
	ClosedAt          pgtype.Timestamp `json:"closedAt"`
	LostReason        *string          `json:"lostReason"`
	OwnerId           *string          `json:"ownerId"`
	Description       *string          `json:"description"`
	UpdatedById       *string          `json:"updatedById"`
}

func (q *Queries) UpdateDeal(ctx context.Context, arg UpdateDealParams) (Deal, error) {
	row := q.db.QueryRow(ctx, updateDeal,
		arg.ID,
		arg.WorkspaceId,
		arg.PipelineId,
		arg.StageId,
		arg.Name,
		arg.Value,
		arg.Currency,
		arg.Stage,
		arg.Probability,
		arg.ExpectedCloseDate,
		arg.ClosedAt,
		arg.LostReason,
		arg.OwnerId,
		arg.Description,
		arg.UpdatedById,
	)
	var i Deal
	err := row.Scan(
		&i.ID,
		&i.WorkspaceId,
		&i.PipelineId,
		&i.StageId,
		&i.ContactId,
		&i.Name,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.DeletedById,
		&i.Description,
		&i.Currency,
		&i.Stage,
		&i.Probability,
		&i.ExpectedCloseDate,
		&i.ClosedAt,
		&i.LostReason,
		&i.CompanyId,
		&i.OwnerId,
		&i.CreatedById,
		&i.UpdatedById,
	)
	return i, err
}
