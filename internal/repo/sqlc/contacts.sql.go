// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: contacts.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const contactExistsInWorkspace = `-- name: ContactExistsInWorkspace :one
SELECT EXISTS(
    SELECT 1
    FROM "Contact"
    WHERE "id" = $1
      AND "workspaceId" = $2
      AND "deletedAt" IS NULL
) AS "exists"
`

type ContactExistsInWorkspaceParams struct {
	ID          string `json:"id"`
	WorkspaceId string `json:"workspaceId"`
}

// Verifica se um contato existe no workspace (usado por validações).
func (q *Queries) ContactExistsInWorkspace(ctx context.Context, arg ContactExistsInWorkspaceParams) (bool, error) {
	row := q.db.QueryRow(ctx, contactExistsInWorkspace, arg.ID, arg.WorkspaceId)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createContact = `-- name: CreateContact :one
INSERT INTO "Contact" (
    "id",
    "fullName",
    "workspaceId",
    "email",
    "phone",
    "whatsapp",
    "notes",
    "firstName",
    "lastName",
    "image",
    "linkedinUrl",
    "language",
    "timezone",
    "city",
    "state",
    "country",
    "jobTitle",
    "department",
    "decisionRole",
    "tagLabels",
    "source",
    "lastInteractionAt",
    "ownerId",
    "socialUrls",
    "companyId",
    "contactScore",
    "lifecycleStage",
    "assignedToId",
    "createdById",
    "updatedById",
    "createdAt",
    "updatedAt"
) VALUES (
    $1,  -- id
    $2,  -- fullName
    $3,  -- workspaceId
    $4,  -- email
    $5,  -- phone
    $6,  -- whatsapp
    $7,  -- notes
    $8,  -- firstName
    $9,  -- lastName
    $10, -- image
    $11, -- linkedinUrl
    $12, -- language
    $13, -- timezone
    $14, -- city
    $15, -- state
    $16, -- country
    $17, -- jobTitle
    $18, -- department
    $19, -- decisionRole
    $20, -- tagLabels
    $21, -- source
    $22, -- lastInteractionAt
    $23, -- ownerId
    $24, -- socialUrls
    $25, -- companyId
    $26, -- contactScore
    $27, -- lifecycleStage
    $28, -- assignedToId
    $29, -- createdById
    $30, -- updatedById
    $31, -- createdAt
    $32  -- updatedAt
)
RETURNING 
    "id",
    "fullName",
    "workspaceId",
    "email",
    "phone",
    "whatsapp",
    "notes",
    "firstName",
    "lastName",
    "image",
    "linkedinUrl",
    "language",
    "timezone",
    "city",
    "state",
    "country",
    "jobTitle",
    "department",
    "decisionRole",
    "tagLabels",
    "source",
    "lastInteractionAt",
    "ownerId",
    "socialUrls",
    "companyId",
    "contactScore",
    "lifecycleStage",
    "assignedToId",
    "createdById",
    "updatedById",
    "createdAt",
    "updatedAt",
    "deletedAt",
    "deletedById"
`

type CreateContactParams struct {
	ID                string                `json:"id"`
	FullName          string                `json:"fullName"`
	WorkspaceId       string                `json:"workspaceId"`
	Email             *string               `json:"email"`
	Phone             *string               `json:"phone"`
	Whatsapp          *string               `json:"whatsapp"`
	Notes             *string               `json:"notes"`
	FirstName         *string               `json:"firstName"`
	LastName          *string               `json:"lastName"`
	Image             *string               `json:"image"`
	LinkedinUrl       *string               `json:"linkedinUrl"`
	Language          *string               `json:"language"`
	Timezone          *string               `json:"timezone"`
	City              *string               `json:"city"`
	State             *string               `json:"state"`
	Country           *string               `json:"country"`
	JobTitle          *string               `json:"jobTitle"`
	Department        *string               `json:"department"`
	DecisionRole      *string               `json:"decisionRole"`
	TagLabels         []string              `json:"tagLabels"`
	Source            *string               `json:"source"`
	LastInteractionAt pgtype.Timestamp      `json:"lastInteractionAt"`
	OwnerId           *string               `json:"ownerId"`
	SocialUrls        []byte                `json:"socialUrls"`
	CompanyId         *string               `json:"companyId"`
	ContactScore      int32                 `json:"contactScore"`
	LifecycleStage    ContactLifecycleStage `json:"lifecycleStage"`
	AssignedToId      *string               `json:"assignedToId"`
	CreatedById       *string               `json:"createdById"`
	UpdatedById       *string               `json:"updatedById"`
	CreatedAt         pgtype.Timestamp      `json:"createdAt"`
	UpdatedAt         pgtype.Timestamp      `json:"updatedAt"`
}

type CreateContactRow struct {
	ID                string                `json:"id"`
	FullName          string                `json:"fullName"`
	WorkspaceId       string                `json:"workspaceId"`
	Email             *string               `json:"email"`
	Phone             *string               `json:"phone"`
	Whatsapp          *string               `json:"whatsapp"`
	Notes             *string               `json:"notes"`
	FirstName         *string               `json:"firstName"`
	LastName          *string               `json:"lastName"`
	Image             *string               `json:"image"`
	LinkedinUrl       *string               `json:"linkedinUrl"`
	Language          *string               `json:"language"`
	Timezone          *string               `json:"timezone"`
	City              *string               `json:"city"`
	State             *string               `json:"state"`
	Country           *string               `json:"country"`
	JobTitle          *string               `json:"jobTitle"`
	Department        *string               `json:"department"`
	DecisionRole      *string               `json:"decisionRole"`
	TagLabels         []string              `json:"tagLabels"`
	Source            *string               `json:"source"`
	LastInteractionAt pgtype.Timestamp      `json:"lastInteractionAt"`
	OwnerId           *string               `json:"ownerId"`
	SocialUrls        []byte                `json:"socialUrls"`
	CompanyId         *string               `json:"companyId"`
	ContactScore      int32                 `json:"contactScore"`
	LifecycleStage    ContactLifecycleStage `json:"lifecycleStage"`
	AssignedToId      *string               `json:"assignedToId"`
	CreatedById       *string               `json:"createdById"`
	UpdatedById       *string               `json:"updatedById"`
	CreatedAt         pgtype.Timestamp      `json:"createdAt"`
	UpdatedAt         pgtype.Timestamp      `json:"updatedAt"`
	DeletedAt         pgtype.Timestamp      `json:"deletedAt"`
	DeletedById       *string               `json:"deletedById"`
}

// Cria um novo contato no workspace (ID gerado pela aplicação).
func (q *Queries) CreateContact(ctx context.Context, arg CreateContactParams) (CreateContactRow, error) {
	row := q.db.QueryRow(ctx, createContact,
		arg.ID,
		arg.FullName,
		arg.WorkspaceId,
		arg.Email,
		arg.Phone,
		arg.Whatsapp,
		arg.Notes,
		arg.FirstName,
		arg.LastName,
		arg.Image,
		arg.LinkedinUrl,
		arg.Language,
		arg.Timezone,
		arg.City,
		arg.State,
		arg.Country,
		arg.JobTitle,
		arg.Department,
		arg.DecisionRole,
		arg.TagLabels,
		arg.Source,
		arg.LastInteractionAt,
		arg.OwnerId,
		arg.SocialUrls,
		arg.CompanyId,
		arg.ContactScore,
		arg.LifecycleStage,
		arg.AssignedToId,
		arg.CreatedById,
		arg.UpdatedById,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i CreateContactRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.WorkspaceId,
		&i.Email,
		&i.Phone,
		&i.Whatsapp,
		&i.Notes,
		&i.FirstName,
		&i.LastName,
		&i.Image,
		&i.LinkedinUrl,
		&i.Language,
		&i.Timezone,
		&i.City,
		&i.State,
		&i.Country,
		&i.JobTitle,
		&i.Department,
		&i.DecisionRole,
		&i.TagLabels,
		&i.Source,
		&i.LastInteractionAt,
		&i.OwnerId,
		&i.SocialUrls,
		&i.CompanyId,
		&i.ContactScore,
		&i.LifecycleStage,
		&i.AssignedToId,
		&i.CreatedById,
		&i.UpdatedById,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.DeletedById,
	)
	return i, err
}

const getContact = `-- name: GetContact :one

SELECT 
    "id",
    "fullName",
    "workspaceId",
    "email",
    "phone",
    "whatsapp",
    "notes",
    "firstName",
    "lastName",
    "image",
    "linkedinUrl",
    "language",
    "timezone",
    "city",
    "state",
    "country",
    "jobTitle",
    "department",
    "decisionRole",
    "tagLabels",
    "source",
    "lastInteractionAt",
    "ownerId",
    "socialUrls",
    "companyId",
    "contactScore",
    "lifecycleStage",
    "assignedToId",
    "createdById",
    "updatedById",
    "createdAt",
    "updatedAt",
    "deletedAt",
    "deletedById"
FROM "Contact"
WHERE "id" = $1
  AND "workspaceId" = $2
  AND "deletedAt" IS NULL
`

type GetContactParams struct {
	ID          string `json:"id"`
	WorkspaceId string `json:"workspaceId"`
}

type GetContactRow struct {
	ID                string                `json:"id"`
	FullName          string                `json:"fullName"`
	WorkspaceId       string                `json:"workspaceId"`
	Email             *string               `json:"email"`
	Phone             *string               `json:"phone"`
	Whatsapp          *string               `json:"whatsapp"`
	Notes             *string               `json:"notes"`
	FirstName         *string               `json:"firstName"`
	LastName          *string               `json:"lastName"`
	Image             *string               `json:"image"`
	LinkedinUrl       *string               `json:"linkedinUrl"`
	Language          *string               `json:"language"`
	Timezone          *string               `json:"timezone"`
	City              *string               `json:"city"`
	State             *string               `json:"state"`
	Country           *string               `json:"country"`
	JobTitle          *string               `json:"jobTitle"`
	Department        *string               `json:"department"`
	DecisionRole      *string               `json:"decisionRole"`
	TagLabels         []string              `json:"tagLabels"`
	Source            *string               `json:"source"`
	LastInteractionAt pgtype.Timestamp      `json:"lastInteractionAt"`
	OwnerId           *string               `json:"ownerId"`
	SocialUrls        []byte                `json:"socialUrls"`
	CompanyId         *string               `json:"companyId"`
	ContactScore      int32                 `json:"contactScore"`
	LifecycleStage    ContactLifecycleStage `json:"lifecycleStage"`
	AssignedToId      *string               `json:"assignedToId"`
	CreatedById       *string               `json:"createdById"`
	UpdatedById       *string               `json:"updatedById"`
	CreatedAt         pgtype.Timestamp      `json:"createdAt"`
	UpdatedAt         pgtype.Timestamp      `json:"updatedAt"`
	DeletedAt         pgtype.Timestamp      `json:"deletedAt"`
	DeletedById       *string               `json:"deletedById"`
}

// =====================================================
// CONTACTS QUERIES - SQLc Generated
// =====================================================
// Tabela: "Contact"
// Schema: camelCase com aspas duplas
// IDs: TEXT (não UUID)
// =====================================================
// Retorna um contato específico de um workspace (IDOR protection).
func (q *Queries) GetContact(ctx context.Context, arg GetContactParams) (GetContactRow, error) {
	row := q.db.QueryRow(ctx, getContact, arg.ID, arg.WorkspaceId)
	var i GetContactRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.WorkspaceId,
		&i.Email,
		&i.Phone,
		&i.Whatsapp,
		&i.Notes,
		&i.FirstName,
		&i.LastName,
		&i.Image,
		&i.LinkedinUrl,
		&i.Language,
		&i.Timezone,
		&i.City,
		&i.State,
		&i.Country,
		&i.JobTitle,
		&i.Department,
		&i.DecisionRole,
		&i.TagLabels,
		&i.Source,
		&i.LastInteractionAt,
		&i.OwnerId,
		&i.SocialUrls,
		&i.CompanyId,
		&i.ContactScore,
		&i.LifecycleStage,
		&i.AssignedToId,
		&i.CreatedById,
		&i.UpdatedById,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.DeletedById,
	)
	return i, err
}

const listContacts = `-- name: ListContacts :many
SELECT 
    "id",
    "fullName",
    "workspaceId",
    "email",
    "phone",
    "whatsapp",
    "notes",
    "firstName",
    "lastName",
    "image",
    "linkedinUrl",
    "language",
    "timezone",
    "city",
    "state",
    "country",
    "jobTitle",
    "department",
    "decisionRole",
    "tagLabels",
    "source",
    "lastInteractionAt",
    "ownerId",
    "socialUrls",
    "companyId",
    "contactScore",
    "lifecycleStage",
    "assignedToId",
    "createdById",
    "updatedById",
    "createdAt",
    "updatedAt",
    "deletedAt",
    "deletedById"
FROM "Contact"
WHERE "workspaceId" = $1
  AND "deletedAt" IS NULL
  AND ($2::TEXT IS NULL OR "ownerId" = $2)
  AND ($3::TEXT IS NULL OR "companyId" = $3)
  AND ($4::TEXT IS NULL OR "lifecycleStage"::TEXT = $4)
  AND ($5::TEXT IS NULL OR to_tsvector('simple', "fullName" || ' ' || COALESCE("email", '')) @@ plainto_tsquery('simple', $5))
  AND ($6::TIMESTAMP IS NULL OR "createdAt" < $6)
ORDER BY "createdAt" DESC
LIMIT $7
`

type ListContactsParams struct {
	WorkspaceId string           `json:"workspaceId"`
	Column2     string           `json:"column2"`
	Column3     string           `json:"column3"`
	Column4     string           `json:"column4"`
	Column5     string           `json:"column5"`
	Column6     pgtype.Timestamp `json:"column6"`
	Limit       int32            `json:"limit"`
}

type ListContactsRow struct {
	ID                string                `json:"id"`
	FullName          string                `json:"fullName"`
	WorkspaceId       string                `json:"workspaceId"`
	Email             *string               `json:"email"`
	Phone             *string               `json:"phone"`
	Whatsapp          *string               `json:"whatsapp"`
	Notes             *string               `json:"notes"`
	FirstName         *string               `json:"firstName"`
	LastName          *string               `json:"lastName"`
	Image             *string               `json:"image"`
	LinkedinUrl       *string               `json:"linkedinUrl"`
	Language          *string               `json:"language"`
	Timezone          *string               `json:"timezone"`
	City              *string               `json:"city"`
	State             *string               `json:"state"`
	Country           *string               `json:"country"`
	JobTitle          *string               `json:"jobTitle"`
	Department        *string               `json:"department"`
	DecisionRole      *string               `json:"decisionRole"`
	TagLabels         []string              `json:"tagLabels"`
	Source            *string               `json:"source"`
	LastInteractionAt pgtype.Timestamp      `json:"lastInteractionAt"`
	OwnerId           *string               `json:"ownerId"`
	SocialUrls        []byte                `json:"socialUrls"`
	CompanyId         *string               `json:"companyId"`
	ContactScore      int32                 `json:"contactScore"`
	LifecycleStage    ContactLifecycleStage `json:"lifecycleStage"`
	AssignedToId      *string               `json:"assignedToId"`
	CreatedById       *string               `json:"createdById"`
	UpdatedById       *string               `json:"updatedById"`
	CreatedAt         pgtype.Timestamp      `json:"createdAt"`
	UpdatedAt         pgtype.Timestamp      `json:"updatedAt"`
	DeletedAt         pgtype.Timestamp      `json:"deletedAt"`
	DeletedById       *string               `json:"deletedById"`
}

// Lista contatos de um workspace com paginação cursor-based (created_at DESC).
// Filtros opcionais: ownerId, companyId, lifecycleStage, query (fulltext search).
func (q *Queries) ListContacts(ctx context.Context, arg ListContactsParams) ([]ListContactsRow, error) {
	rows, err := q.db.Query(ctx, listContacts,
		arg.WorkspaceId,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListContactsRow{}
	for rows.Next() {
		var i ListContactsRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.WorkspaceId,
			&i.Email,
			&i.Phone,
			&i.Whatsapp,
			&i.Notes,
			&i.FirstName,
			&i.LastName,
			&i.Image,
			&i.LinkedinUrl,
			&i.Language,
			&i.Timezone,
			&i.City,
			&i.State,
			&i.Country,
			&i.JobTitle,
			&i.Department,
			&i.DecisionRole,
			&i.TagLabels,
			&i.Source,
			&i.LastInteractionAt,
			&i.OwnerId,
			&i.SocialUrls,
			&i.CompanyId,
			&i.ContactScore,
			&i.LifecycleStage,
			&i.AssignedToId,
			&i.CreatedById,
			&i.UpdatedById,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.DeletedById,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchContactsByText = `-- name: SearchContactsByText :many
SELECT 
    "id",
    "fullName",
    "email",
    "phone",
    "companyId",
    "lifecycleStage",
    "contactScore"
FROM "Contact"
WHERE "workspaceId" = $1
  AND "deletedAt" IS NULL
  AND to_tsvector('simple', "fullName" || ' ' || COALESCE("email", '') || ' ' || COALESCE("phone", '')) @@ plainto_tsquery('simple', $2)
ORDER BY "contactScore" DESC, "createdAt" DESC
LIMIT $3
`

type SearchContactsByTextParams struct {
	WorkspaceId    string `json:"workspaceId"`
	PlaintoTsquery string `json:"plaintoTsquery"`
	Limit          int32  `json:"limit"`
}

type SearchContactsByTextRow struct {
	ID             string                `json:"id"`
	FullName       string                `json:"fullName"`
	Email          *string               `json:"email"`
	Phone          *string               `json:"phone"`
	CompanyId      *string               `json:"companyId"`
	LifecycleStage ContactLifecycleStage `json:"lifecycleStage"`
	ContactScore   int32                 `json:"contactScore"`
}

// Busca fulltext em contatos (usado por autocomplete/search).
func (q *Queries) SearchContactsByText(ctx context.Context, arg SearchContactsByTextParams) ([]SearchContactsByTextRow, error) {
	rows, err := q.db.Query(ctx, searchContactsByText, arg.WorkspaceId, arg.PlaintoTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchContactsByTextRow{}
	for rows.Next() {
		var i SearchContactsByTextRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Email,
			&i.Phone,
			&i.CompanyId,
			&i.LifecycleStage,
			&i.ContactScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteContact = `-- name: SoftDeleteContact :exec
UPDATE "Contact"
SET
    "deletedAt" = $3,
    "deletedById" = $4,
    "updatedAt" = $3
WHERE "id" = $1
  AND "workspaceId" = $2
  AND "deletedAt" IS NULL
`

type SoftDeleteContactParams struct {
	ID          string           `json:"id"`
	WorkspaceId string           `json:"workspaceId"`
	DeletedAt   pgtype.Timestamp `json:"deletedAt"`
	DeletedById *string          `json:"deletedById"`
}

// Soft delete de um contato (marca deletedAt + deletedById).
func (q *Queries) SoftDeleteContact(ctx context.Context, arg SoftDeleteContactParams) error {
	_, err := q.db.Exec(ctx, softDeleteContact,
		arg.ID,
		arg.WorkspaceId,
		arg.DeletedAt,
		arg.DeletedById,
	)
	return err
}

const updateContact = `-- name: UpdateContact :one
UPDATE "Contact"
SET
    "fullName" = COALESCE($3, "fullName"),
    "email" = COALESCE($4, "email"),
    "phone" = COALESCE($5, "phone"),
    "whatsapp" = COALESCE($6, "whatsapp"),
    "notes" = COALESCE($7, "notes"),
    "firstName" = COALESCE($8, "firstName"),
    "lastName" = COALESCE($9, "lastName"),
    "image" = COALESCE($10, "image"),
    "linkedinUrl" = COALESCE($11, "linkedinUrl"),
    "language" = COALESCE($12, "language"),
    "timezone" = COALESCE($13, "timezone"),
    "city" = COALESCE($14, "city"),
    "state" = COALESCE($15, "state"),
    "country" = COALESCE($16, "country"),
    "jobTitle" = COALESCE($17, "jobTitle"),
    "department" = COALESCE($18, "department"),
    "decisionRole" = COALESCE($19, "decisionRole"),
    "tagLabels" = COALESCE($20, "tagLabels"),
    "source" = COALESCE($21, "source"),
    "lastInteractionAt" = COALESCE($22, "lastInteractionAt"),
    "ownerId" = COALESCE($23, "ownerId"),
    "socialUrls" = COALESCE($24, "socialUrls"),
    "companyId" = COALESCE($25, "companyId"),
    "contactScore" = COALESCE($26, "contactScore"),
    "lifecycleStage" = COALESCE($27, "lifecycleStage"),
    "assignedToId" = COALESCE($28, "assignedToId"),
    "updatedById" = $29,
    "updatedAt" = $30
WHERE "id" = $1
  AND "workspaceId" = $2
  AND "deletedAt" IS NULL
  AND "updatedAt" = $31  -- Optimistic locking
RETURNING 
    "id",
    "fullName",
    "workspaceId",
    "email",
    "phone",
    "whatsapp",
    "notes",
    "firstName",
    "lastName",
    "image",
    "linkedinUrl",
    "language",
    "timezone",
    "city",
    "state",
    "country",
    "jobTitle",
    "department",
    "decisionRole",
    "tagLabels",
    "source",
    "lastInteractionAt",
    "ownerId",
    "socialUrls",
    "companyId",
    "contactScore",
    "lifecycleStage",
    "assignedToId",
    "createdById",
    "updatedById",
    "createdAt",
    "updatedAt",
    "deletedAt",
    "deletedById"
`

type UpdateContactParams struct {
	ID                string                `json:"id"`
	WorkspaceId       string                `json:"workspaceId"`
	FullName          string                `json:"fullName"`
	Email             *string               `json:"email"`
	Phone             *string               `json:"phone"`
	Whatsapp          *string               `json:"whatsapp"`
	Notes             *string               `json:"notes"`
	FirstName         *string               `json:"firstName"`
	LastName          *string               `json:"lastName"`
	Image             *string               `json:"image"`
	LinkedinUrl       *string               `json:"linkedinUrl"`
	Language          *string               `json:"language"`
	Timezone          *string               `json:"timezone"`
	City              *string               `json:"city"`
	State             *string               `json:"state"`
	Country           *string               `json:"country"`
	JobTitle          *string               `json:"jobTitle"`
	Department        *string               `json:"department"`
	DecisionRole      *string               `json:"decisionRole"`
	TagLabels         []string              `json:"tagLabels"`
	Source            *string               `json:"source"`
	LastInteractionAt pgtype.Timestamp      `json:"lastInteractionAt"`
	OwnerId           *string               `json:"ownerId"`
	SocialUrls        []byte                `json:"socialUrls"`
	CompanyId         *string               `json:"companyId"`
	ContactScore      int32                 `json:"contactScore"`
	LifecycleStage    ContactLifecycleStage `json:"lifecycleStage"`
	AssignedToId      *string               `json:"assignedToId"`
	UpdatedById       *string               `json:"updatedById"`
	UpdatedAt         pgtype.Timestamp      `json:"updatedAt"`
	UpdatedAt_2       pgtype.Timestamp      `json:"updatedAt2"`
}

type UpdateContactRow struct {
	ID                string                `json:"id"`
	FullName          string                `json:"fullName"`
	WorkspaceId       string                `json:"workspaceId"`
	Email             *string               `json:"email"`
	Phone             *string               `json:"phone"`
	Whatsapp          *string               `json:"whatsapp"`
	Notes             *string               `json:"notes"`
	FirstName         *string               `json:"firstName"`
	LastName          *string               `json:"lastName"`
	Image             *string               `json:"image"`
	LinkedinUrl       *string               `json:"linkedinUrl"`
	Language          *string               `json:"language"`
	Timezone          *string               `json:"timezone"`
	City              *string               `json:"city"`
	State             *string               `json:"state"`
	Country           *string               `json:"country"`
	JobTitle          *string               `json:"jobTitle"`
	Department        *string               `json:"department"`
	DecisionRole      *string               `json:"decisionRole"`
	TagLabels         []string              `json:"tagLabels"`
	Source            *string               `json:"source"`
	LastInteractionAt pgtype.Timestamp      `json:"lastInteractionAt"`
	OwnerId           *string               `json:"ownerId"`
	SocialUrls        []byte                `json:"socialUrls"`
	CompanyId         *string               `json:"companyId"`
	ContactScore      int32                 `json:"contactScore"`
	LifecycleStage    ContactLifecycleStage `json:"lifecycleStage"`
	AssignedToId      *string               `json:"assignedToId"`
	CreatedById       *string               `json:"createdById"`
	UpdatedById       *string               `json:"updatedById"`
	CreatedAt         pgtype.Timestamp      `json:"createdAt"`
	UpdatedAt         pgtype.Timestamp      `json:"updatedAt"`
	DeletedAt         pgtype.Timestamp      `json:"deletedAt"`
	DeletedById       *string               `json:"deletedById"`
}

// Atualiza um contato existente (IDOR protection + optimistic locking via updatedAt).
func (q *Queries) UpdateContact(ctx context.Context, arg UpdateContactParams) (UpdateContactRow, error) {
	row := q.db.QueryRow(ctx, updateContact,
		arg.ID,
		arg.WorkspaceId,
		arg.FullName,
		arg.Email,
		arg.Phone,
		arg.Whatsapp,
		arg.Notes,
		arg.FirstName,
		arg.LastName,
		arg.Image,
		arg.LinkedinUrl,
		arg.Language,
		arg.Timezone,
		arg.City,
		arg.State,
		arg.Country,
		arg.JobTitle,
		arg.Department,
		arg.DecisionRole,
		arg.TagLabels,
		arg.Source,
		arg.LastInteractionAt,
		arg.OwnerId,
		arg.SocialUrls,
		arg.CompanyId,
		arg.ContactScore,
		arg.LifecycleStage,
		arg.AssignedToId,
		arg.UpdatedById,
		arg.UpdatedAt,
		arg.UpdatedAt_2,
	)
	var i UpdateContactRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.WorkspaceId,
		&i.Email,
		&i.Phone,
		&i.Whatsapp,
		&i.Notes,
		&i.FirstName,
		&i.LastName,
		&i.Image,
		&i.LinkedinUrl,
		&i.Language,
		&i.Timezone,
		&i.City,
		&i.State,
		&i.Country,
		&i.JobTitle,
		&i.Department,
		&i.DecisionRole,
		&i.TagLabels,
		&i.Source,
		&i.LastInteractionAt,
		&i.OwnerId,
		&i.SocialUrls,
		&i.CompanyId,
		&i.ContactScore,
		&i.LifecycleStage,
		&i.AssignedToId,
		&i.CreatedById,
		&i.UpdatedById,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.DeletedById,
	)
	return i, err
}
